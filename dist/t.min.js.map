{"version":3,"sources":["webpack:///t.min.js","webpack:///webpack/bootstrap a006347fa09d87b1683d","webpack:///./src/index.js","webpack:///./src/expr.js","webpack:///./src/token.js","webpack:///./src/binding.js","webpack:///./src/accessor.js","webpack:///./src/annotation.js","webpack:///./src/serializer.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","nextId","templateId","slotName","element","SLOT_SUPPORTED","name","getAttribute","slotAppend","slot","node","root","__appended","__fallbackContent","innerHTML","appendChild","elementSlot","fixTemplate","template","content","window","HTMLTemplateElement","decorate","T","host","marker","this","__templateInitialize","_typeof","Symbol","iterator","obj","constructor","Expr","Binding","Accessor","Annotation","Token","Serializer","document","createElement","HTMLUnknownElement","prototype","__templateId","__templateBindings","__templateHost","parentElement","__templateMarker","$","__template","__templateFragment","importNode","__parseAnnotations","createComment","$$","selector","querySelector","render","_this","forEach","querySelectorAll","nodeType","Node","ELEMENT_NODE","err","console","error","stack","insertBefore","get","path","object","segments","split","some","segment","undefined","set","value","oldValue","slice","property","pop","notify","binding","__templateGetBinding","walkEffect","warn","message","_this2","len","childNodes","length","i","__parseElementAnnotations","TEXT_NODE","__parseTextAnnotations","Object","keys","key","__parseEventAnnotations","attrName","attrValue","eventName","context","expr","getFn","addEventListener","evt","invoke","__parseAttributeAnnotations","_this3","Array","attributes","reduce","annotated","attr","indexOf","__templateAnnotate","scoped","__templateModel","classList","add","is","childNodesLength","childNode","textContent","accessor","nodeName","_this4","type","annotation","annotatedPaths","arg","annotations","push","bindings","paths","_classCallCheck","instance","Constructor","TypeError","unwrapped","args","join","rawTokenize","str","count","tokens","matches","match","substr","trim","tokenize","map","token","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","mode","Boolean","valType","otherArgs","fn","Error","apply","_annotatedPaths","global","GLOBAL","JSON","parse","_value","others","val","model","effect","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","BaseAccessor","endsWith","AttributeAccessor","ValueAccessor","TextAccessor","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_BaseAccessor","textContext","_BaseAccessor2","arguments","_BaseAccessor3","setAttribute","removeAttribute","serialize","Date","stringify","deserialize","Number"],"mappings":"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","file":"t.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/* globals Node, HTMLUnknownElement */\n\tvar Expr = __webpack_require__(1);\n\tvar Binding = __webpack_require__(3);\n\tvar Accessor = __webpack_require__(4);\n\tvar Annotation = __webpack_require__(5);\n\tvar Token = __webpack_require__(2);\n\tvar Serializer = __webpack_require__(6);\n\t\n\tvar SLOT_SUPPORTED = 'HTMLUnknownElement' in window && !(document.createElement('slot') instanceof HTMLUnknownElement);\n\t\n\tvar templateId = 0;\n\t\n\tfunction nextId() {\n\t  return templateId++;\n\t}\n\t\n\tfunction slotName(element) {\n\t  return SLOT_SUPPORTED ? element.name : element.getAttribute('name');\n\t}\n\t\n\tfunction slotAppend(slot, node, root) {\n\t  if (!slot.__appended) {\n\t    slot.__appended = true;\n\t    slot.__fallbackContent = slot.innerHTML;\n\t    slot.innerHTML = '';\n\t  }\n\t\n\t  slot.appendChild(node);\n\t}\n\t\n\tfunction elementSlot(element) {\n\t  return SLOT_SUPPORTED ? element.slot : element.getAttribute('slot');\n\t}\n\t\n\tfunction fixTemplate(template) {\n\t  if (!template.content && window.HTMLTemplateElement && window.HTMLTemplateElement.decorate) {\n\t    window.HTMLTemplateElement.decorate(template);\n\t  }\n\t  return template;\n\t}\n\t\n\tfunction T(template, host, marker) {\n\t  this.__templateInitialize(template, host, marker);\n\t}\n\t\n\tT.prototype = {\n\t  __templateInitialize: function __templateInitialize(template, host, marker) {\n\t    this.__templateId = nextId();\n\t    // this.__templateAnnotatedElements = [];\n\t    this.__templateBindings = {};\n\t    this.__templateHost = host || (template ? template.parentElement : null);\n\t    this.__templateMarker = marker;\n\t    this.$ = {};\n\t\n\t    if (!template) {\n\t      return;\n\t    }\n\t\n\t    // do below only if template is exists\n\t    this.__template = fixTemplate(template);\n\t    this.__templateFragment = document.importNode(this.__template.content, true);\n\t\n\t    this.__parseAnnotations();\n\t\n\t    if (marker) {\n\t      return;\n\t    }\n\t\n\t    if (this.__template.parentElement === this.__templateHost) {\n\t      // when template parent is template host, it means that template is specific template\n\t      // then use template as marker\n\t      this.__templateMarker = this.__template;\n\t    } else {\n\t      // when template is not child of host, put marker to host\n\t      this.__templateMarker = document.createComment('marker-' + this.__templateId);\n\t      this.__templateHost.appendChild(this.__templateMarker);\n\t    }\n\t  },\n\t  $$: function $$(selector) {\n\t    return this.querySelector(selector);\n\t  },\n\t  render: function render(content) {\n\t    var _this = this;\n\t\n\t    if (!this.__templateFragment) {\n\t      return;\n\t    }\n\t\n\t    if (content) {\n\t      try {\n\t        [].forEach.call(this.__templateFragment.querySelectorAll('slot'), function (slot) {\n\t          var name = slotName(slot);\n\t          if (name) {\n\t            content.forEach(function (node) {\n\t              if (node.nodeType === Node.ELEMENT_NODE && name === elementSlot(node)) {\n\t                slotAppend(slot, node, _this.__templateFragment);\n\t              }\n\t              // TODO query to childnodes looking for slot\n\t            });\n\t          } else {\n\t            content.forEach(function (node) {\n\t              slotAppend(slot, node, _this.__templateFragment);\n\t            });\n\t          }\n\t        });\n\t      } catch (err) {\n\t        console.error(err.stack);\n\t        throw err;\n\t      }\n\t    }\n\t\n\t    this.__templateMarker.parentElement.insertBefore(this.__templateFragment, this.__templateMarker);\n\t  },\n\t  get: function get(path) {\n\t    var object = this;\n\t\n\t    var segments = path.split('.');\n\t\n\t    segments.some(function (segment) {\n\t      if (object === undefined || object === null) {\n\t        object = undefined;\n\t        return true;\n\t      }\n\t\n\t      object = object[segment];\n\t      return false;\n\t    });\n\t\n\t    return object;\n\t  },\n\t  set: function set(path, value) {\n\t    var oldValue = this.get(path);\n\t\n\t    if (value === oldValue) {\n\t      return;\n\t    }\n\t\n\t    var object = this;\n\t\n\t    var segments = path.split('.');\n\t\n\t    segments.slice(0, -1).forEach(function (segment) {\n\t      if (!object) {\n\t        return;\n\t      }\n\t      if (object[segment] === undefined || object[segment] === null) {\n\t        object[segment] = {};\n\t      }\n\t\n\t      object = object[segment];\n\t    });\n\t\n\t    var property = segments.slice(-1).pop();\n\t\n\t    object[property] = value;\n\t\n\t    this.notify(path, value, oldValue);\n\t  },\n\t  notify: function notify(path, value, oldValue) {\n\t    try {\n\t      var binding = this.__templateGetBinding(path);\n\t      if (binding) {\n\t        binding.walkEffect(value);\n\t      }\n\t    } catch (err) {\n\t      console.warn('#notify caught error: ' + err.message + '\\n Stack trace: ' + err.stack);\n\t    }\n\t  },\n\t  __parseAnnotations: function __parseAnnotations() {\n\t    var _this2 = this;\n\t\n\t    // this.__templateAnnotatedElements = [];\n\t\n\t    // [].forEach.call(this.__templateFragment.querySelectorAll('*'), (el) => {\n\t    //   console.warn(this.is, !!el.__templateModel, el);\n\t    // });\n\t\n\t    var len = this.__templateFragment.childNodes.length;\n\t    for (var i = 0; i < len; i++) {\n\t      var node = this.__templateFragment.childNodes[i];\n\t      switch (node.nodeType) {\n\t        case Node.ELEMENT_NODE:\n\t          this.__parseElementAnnotations(node);\n\t          break;\n\t        case Node.TEXT_NODE:\n\t          this.__parseTextAnnotations(node);\n\t          break;\n\t      }\n\t    }\n\t\n\t    Object.keys(this.__templateBindings).forEach(function (key) {\n\t      _this2.notify(key, _this2.get(key));\n\t    });\n\t  },\n\t  __parseEventAnnotations: function __parseEventAnnotations(element, attrName) {\n\t    // bind event annotation\n\t    var attrValue = element.getAttribute(attrName);\n\t    var eventName = attrName.slice(1, -1);\n\t    // let eventName = attrName.substr(3);\n\t    if (eventName === 'tap') {\n\t      eventName = 'click';\n\t    }\n\t\n\t    var context = this;\n\t    var expr = Expr.getFn(attrValue, [], true);\n\t\n\t    // TODO might be slow or memory leak setting event listener to inside element\n\t    element.addEventListener(eventName, function (evt) {\n\t      return expr.invoke(context, { evt: evt });\n\t    }, true);\n\t  },\n\t  __parseAttributeAnnotations: function __parseAttributeAnnotations(element) {\n\t    var _this3 = this;\n\t\n\t    // clone attributes to array first then foreach because we will remove\n\t    // attribute later if already processed\n\t    // this hack to make sure when attribute removed the attributes index doesnt shift.\n\t    return Array.prototype.slice.call(element.attributes).reduce(function (annotated, attr) {\n\t      var attrName = attr.name;\n\t\n\t      if (attrName.indexOf('(') === 0) {\n\t        _this3.__parseEventAnnotations(element, attrName);\n\t      } else {\n\t        // bind property annotation\n\t        annotated = _this3.__templateAnnotate(Expr.get(attr.value), Accessor.get(element, attrName)) || annotated;\n\t      }\n\t\n\t      return annotated;\n\t    }, false);\n\t  },\n\t  __parseElementAnnotations: function __parseElementAnnotations(element) {\n\t    var annotated = false;\n\t    var scoped = element.__templateModel;\n\t\n\t    if (!scoped) {\n\t      element.classList.add(this.__templateHost.is + '__scope');\n\t      element.__templateModel = this;\n\t\n\t      // populate $\n\t      if (element.id && !this.$[element.id]) {\n\t        this.$[element.id] = element;\n\t      }\n\t\n\t      if (element.attributes && element.attributes.length) {\n\t        annotated = this.__parseAttributeAnnotations(element) || annotated;\n\t      }\n\t    }\n\t\n\t    if (element.childNodes && element.childNodes.length) {\n\t      var childNodes = [].slice.call(element.childNodes);\n\t      var childNodesLength = childNodes.length;\n\t\n\t      for (var i = 0; i < childNodesLength; i++) {\n\t        var childNode = childNodes[i];\n\t\n\t        switch (childNode.nodeType) {\n\t          case Node.TEXT_NODE:\n\t            if (!scoped) {\n\t              annotated = this.__parseTextAnnotations(childNode) || annotated;\n\t            }\n\t            break;\n\t          case Node.ELEMENT_NODE:\n\t            annotated = this.__parseElementAnnotations(childNode) || annotated;\n\t            break;\n\t          default:\n\t          // noop\n\t        }\n\t      }\n\t    }\n\t\n\t    // if (annotated) {\n\t    //   this.__templateAnnotatedElements.push(element);\n\t    // }\n\t\n\t    return annotated;\n\t  },\n\t  __parseTextAnnotations: function __parseTextAnnotations(node) {\n\t    var expr = Expr.get(node.textContent);\n\t\n\t    var accessor = void 0;\n\t    if (node.parentElement && node.parentElement.nodeName === 'TEXTAREA') {\n\t      accessor = Accessor.get(node.parentElement, 'value');\n\t    } else {\n\t      accessor = Accessor.get(node);\n\t    }\n\t\n\t    return this.__templateAnnotate(expr, accessor);\n\t  },\n\t  __templateAnnotate: function __templateAnnotate(expr, accessor) {\n\t    var _this4 = this;\n\t\n\t    if (expr.type === 's') {\n\t      return false;\n\t    }\n\t\n\t    // annotate every paths\n\t    var annotation = new Annotation(this, expr, accessor);\n\t\n\t    expr.annotatedPaths.forEach(function (arg) {\n\t      return _this4.__templateGetBinding(arg.name).annotations.push(annotation);\n\t    });\n\t\n\t    return true;\n\t  },\n\t  __templateGetBinding: function __templateGetBinding(path) {\n\t    var segments = path.split('.');\n\t    var bindings = void 0;\n\t    var binding = void 0;\n\t\n\t    for (var i = 0; i < segments.length; i++) {\n\t      var segment = segments[i];\n\t\n\t      bindings = binding ? binding.paths : this.__templateBindings;\n\t\n\t      if (!bindings[segment]) {\n\t        bindings[segment] = new Binding(this, segment);\n\t      }\n\t\n\t      binding = bindings[segment];\n\t    }\n\t\n\t    return binding;\n\t  }\n\t};\n\t\n\tif ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {\n\t  window.T = T;\n\t}\n\t\n\tmodule.exports = T;\n\tmodule.exports.Accessor = Accessor;\n\tmodule.exports.Expr = Expr;\n\tmodule.exports.Token = Token;\n\tmodule.exports.Serializer = Serializer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Token = __webpack_require__(2);\n\t\n\tvar Expr = function () {\n\t  function Expr(value, unwrapped) {\n\t    _classCallCheck(this, Expr);\n\t\n\t    // define base properties\n\t    this.mode = '[';\n\t    this.type = 's';\n\t    this.name = '';\n\t    this.args = [];\n\t    this.value = value;\n\t    this.unwrapped = Boolean(unwrapped);\n\t\n\t    var valType = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\t    if (valType === 'function') {\n\t      this.type = 'm';\n\t      return;\n\t    } else if (valType !== 'string') {\n\t      // validate args\n\t      return;\n\t    }\n\t\n\t    // cleanse value\n\t    value = value.trim();\n\t\n\t    var token = value;\n\t    if (!this.unwrapped) {\n\t      if (value[0] !== '[' && value[0] !== '{') {\n\t        return;\n\t      }\n\t      token = value.slice(2, -2).trim();\n\t      this.mode = value[0];\n\t    }\n\t\n\t    if (token.indexOf('(') < 0) {\n\t      this.type = 'p';\n\t      this.name = token;\n\t      this.args.push(new Token(token));\n\t    } else {\n\t      // force mode to '[' when type is !p\n\t      this.mode = '[';\n\t      this.type = 'm';\n\t\n\t      var matches = token.match(/([^(]+)\\(([^)]*)\\)/);\n\t\n\t      this.name = matches[1].trim();\n\t\n\t      this.args = tokenize(matches[2]);\n\t    }\n\t  }\n\t\n\t  _createClass(Expr, [{\n\t    key: 'invoke',\n\t    value: function invoke(context, otherArgs) {\n\t      if (this.type === 'p') {\n\t        return typeof context.get === 'function' ? context.get(this.name) : context[this.name];\n\t      }\n\t\n\t      var fn = context.__templateHost[this.name];\n\t      if (typeof fn !== 'function') {\n\t        throw new Error('Method is not eligible, ' + (context.__templateHost.nodeName || '$anonymous') + '#' + this.name);\n\t      }\n\t\n\t      var args = this.args.map(function (arg) {\n\t        return arg.value(context, otherArgs);\n\t      });\n\t\n\t      return fn.apply(context, args);\n\t    }\n\t  }, {\n\t    key: 'annotatedPaths',\n\t    get: function get() {\n\t      var _this = this;\n\t\n\t      if (!this._annotatedPaths) {\n\t        (function () {\n\t          var annotatedPaths = [];\n\t          _this.args.forEach(function (arg) {\n\t            if (arg.type === 'v' && annotatedPaths.indexOf(arg.name) === -1) {\n\t              annotatedPaths.push(arg);\n\t            }\n\t          });\n\t          _this._annotatedPaths = annotatedPaths;\n\t        })();\n\t      }\n\t\n\t      return this._annotatedPaths;\n\t    }\n\t  }]);\n\t\n\t  return Expr;\n\t}();\n\t\n\tfunction get(value, unwrapped) {\n\t  // FIXME implement cache\n\t  return new Expr(value, unwrapped);\n\t}\n\t\n\tfunction getFn(value, args, unwrapped) {\n\t  if (typeof value === 'function') {\n\t    return get(value, unwrapped);\n\t  }\n\t  return get(value.indexOf('(') === -1 ? value + '(' + args.join(', ') + ')' : value, unwrapped);\n\t}\n\t\n\tfunction rawTokenize(str) {\n\t  var count = 0;\n\t  var tokens = [];\n\t\n\t  while (str && count++ < 10) {\n\t    var matches = str.match(/^\\s*(\"[^\"]*\"|[^,]+),?/);\n\t\n\t    str = str.substr(matches[0].length);\n\t    tokens.push(matches[1].trim());\n\t  }\n\t\n\t  return tokens;\n\t}\n\t\n\tfunction tokenize(str) {\n\t  return rawTokenize(str).map(function (token) {\n\t    return new Token(token);\n\t  });\n\t}\n\t\n\tmodule.exports = Expr;\n\tmodule.exports.getFn = getFn;\n\tmodule.exports.get = get;\n\tmodule.exports.rawTokenize = rawTokenize;\n\tmodule.exports.tokenize = tokenize;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GLOBAL = global || window;\n\t\n\tvar Token = function () {\n\t  function Token(name) {\n\t    _classCallCheck(this, Token);\n\t\n\t    this.name = name;\n\t    try {\n\t      var value = JSON.parse(this.name);\n\t      this.type = 's';\n\t      this._value = value;\n\t    } catch (err) {\n\t      this.type = 'v';\n\t      this._value = null;\n\t    }\n\t  }\n\t\n\t  _createClass(Token, [{\n\t    key: 'value',\n\t    value: function value(context, others) {\n\t      context = context || GLOBAL;\n\t\n\t      if (this.type === 's') {\n\t        return this._value;\n\t      }\n\t\n\t      if (context) {\n\t        var val = context.get ? context.get(this.name) : context[this.name];\n\t        if (typeof val !== 'undefined') {\n\t          return val;\n\t        }\n\t      }\n\t\n\t      if (others) {\n\t        var _val = others.get ? others.get(this.name) : others[this.name];\n\t        if (typeof _val !== 'undefined') {\n\t          return _val;\n\t        }\n\t      }\n\t\n\t      return;\n\t    }\n\t  }]);\n\t\n\t  return Token;\n\t}();\n\t\n\tfunction get(name) {\n\t  // FIXME implement cache\n\t  return new Token(name);\n\t}\n\t\n\tmodule.exports = Token;\n\tmodule.exports.get = get;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Binding = function () {\n\t  function Binding(context, model) {\n\t    _classCallCheck(this, Binding);\n\t\n\t    this.context = context;\n\t    this.model = model;\n\t    this.paths = {};\n\t    this.annotations = [];\n\t  }\n\t\n\t  _createClass(Binding, [{\n\t    key: 'walkEffect',\n\t    value: function walkEffect(value) {\n\t      var _this = this;\n\t\n\t      this.annotations.forEach(function (annotation) {\n\t        try {\n\t          annotation.effect(value, _this.model);\n\t        } catch (err) {\n\t          console.error('Error caught while walk effect annotation: ' + (annotation.expr ? annotation.expr.value : '#unknown') + '\\n ' + err.stack);\n\t        }\n\t      });\n\t\n\t      Object.keys(this.paths).forEach(function (i) {\n\t        _this.paths[i].walkEffect(value ? value[i] : undefined);\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Binding;\n\t}();\n\t\n\tmodule.exports = Binding;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* globals Node */\n\t\n\tvar BaseAccessor = function () {\n\t  function BaseAccessor(node, name) {\n\t    _classCallCheck(this, BaseAccessor);\n\t\n\t    this.node = node;\n\t    this.name = name;\n\t  }\n\t\n\t  _createClass(BaseAccessor, [{\n\t    key: 'set',\n\t    value: function set(value) {\n\t      if (typeof this.node.set === 'function') {\n\t        this.node.set(this.name, value);\n\t      } else {\n\t        this.node[this.name] = value;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get() {\n\t      if (typeof this.node.get === 'function') {\n\t        return this.node.get(this.name);\n\t      } else {\n\t        return this.node[this.name];\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return BaseAccessor;\n\t}();\n\t\n\tvar TextAccessor = function (_BaseAccessor) {\n\t  _inherits(TextAccessor, _BaseAccessor);\n\t\n\t  function TextAccessor(node) {\n\t    _classCallCheck(this, TextAccessor);\n\t\n\t    return _possibleConstructorReturn(this, (TextAccessor.__proto__ || Object.getPrototypeOf(TextAccessor)).call(this, node, 'textContent'));\n\t  }\n\t\n\t  _createClass(TextAccessor, [{\n\t    key: 'set',\n\t    value: function set(value) {\n\t      this.node.textContent = value || '';\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get() {\n\t      return this.node.textContext;\n\t    }\n\t  }]);\n\t\n\t  return TextAccessor;\n\t}(BaseAccessor);\n\t\n\tvar ValueAccessor = function (_BaseAccessor2) {\n\t  _inherits(ValueAccessor, _BaseAccessor2);\n\t\n\t  function ValueAccessor() {\n\t    _classCallCheck(this, ValueAccessor);\n\t\n\t    return _possibleConstructorReturn(this, (ValueAccessor.__proto__ || Object.getPrototypeOf(ValueAccessor)).apply(this, arguments));\n\t  }\n\t\n\t  _createClass(ValueAccessor, [{\n\t    key: 'set',\n\t    value: function set(value) {\n\t      _get(ValueAccessor.prototype.__proto__ || Object.getPrototypeOf(ValueAccessor.prototype), 'set', this).call(this, value || '');\n\t    }\n\t  }]);\n\t\n\t  return ValueAccessor;\n\t}(BaseAccessor);\n\t\n\tvar AttributeAccessor = function (_BaseAccessor3) {\n\t  _inherits(AttributeAccessor, _BaseAccessor3);\n\t\n\t  function AttributeAccessor(node, name) {\n\t    _classCallCheck(this, AttributeAccessor);\n\t\n\t    return _possibleConstructorReturn(this, (AttributeAccessor.__proto__ || Object.getPrototypeOf(AttributeAccessor)).call(this, node, name.slice(0, -1)));\n\t  }\n\t\n\t  _createClass(AttributeAccessor, [{\n\t    key: 'set',\n\t    value: function set(value) {\n\t      if (value) {\n\t        this.node.setAttribute(this.name, value);\n\t      } else {\n\t        this.node.removeAttribute(this.name);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get() {\n\t      return this.node.getAttribute(this.name);\n\t    }\n\t  }]);\n\t\n\t  return AttributeAccessor;\n\t}(BaseAccessor);\n\t\n\tfunction get(node, name) {\n\t  if (node && 'nodeType' in node) {\n\t    switch (node.nodeType) {\n\t      case Node.ELEMENT_NODE:\n\t        if (name.endsWith('$')) {\n\t          return new AttributeAccessor(node, name);\n\t        } else if (name === 'value') {\n\t          return new ValueAccessor(node, name);\n\t        }\n\t\n\t        return new BaseAccessor(node, name);\n\t      case Node.TEXT_NODE:\n\t        if (node.parentElement && node.parentElement.nodeName === 'TEXTAREA') {\n\t          return new ValueAccessor(node.parentElement, 'value');\n\t        }\n\t\n\t        return new TextAccessor(node);\n\t      default:\n\t        throw new Error('Unimplemented resolving accessor for nodeType: ' + node.nodeType);\n\t    }\n\t  } else {\n\t    return new BaseAccessor(node, name);\n\t  }\n\t}\n\t\n\tmodule.exports = BaseAccessor;\n\tmodule.exports.get = get;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Annotation = function () {\n\t  function Annotation(model, expr, accessor) {\n\t    _classCallCheck(this, Annotation);\n\t\n\t    this.model = model;\n\t    this.expr = expr;\n\t    this.accessor = accessor;\n\t  }\n\t\n\t  _createClass(Annotation, [{\n\t    key: \"effect\",\n\t    value: function effect(value) {\n\t      if (this.accessor) {\n\t        var _value = this.expr.invoke(this.model);\n\t        // FIXME implement composite annotation\n\t        // FIXME implement filtered annotation\n\t        // FIXME implement function type annotation\n\t        this.accessor.set(_value);\n\t      } else {\n\t        this.expr.invoke(this.model);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Annotation;\n\t}();\n\t\n\tmodule.exports = Annotation;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction serialize(value) {\n\t  switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n\t    case 'boolean':\n\t      return value ? '' : undefined;\n\t\n\t    case 'object':\n\t      if (value instanceof Date) {\n\t        return value;\n\t      } else if (value) {\n\t        try {\n\t          return JSON.stringify(value);\n\t        } catch (err) {\n\t          return '';\n\t        }\n\t      }\n\t      break;\n\t    default:\n\t    // noop\n\t  }\n\t  return value === null ? undefined : value;\n\t}\n\t\n\tfunction deserialize(value, type) {\n\t  switch (type) {\n\t    case Number:\n\t      value = Number(value);\n\t      break;\n\t\n\t    case Boolean:\n\t      value = Boolean(value === '' || value === 'true' || value === '1' || value === 'on');\n\t      break;\n\t\n\t    case Object:\n\t      try {\n\t        value = JSON.parse(value);\n\t      } catch (err) {\n\t        // allow non-JSON literals like Strings and Numbers\n\t        // console.warn('Failed decode json: \"' + value + '\" to Object');\n\t      }\n\t      break;\n\t\n\t    case Array:\n\t      try {\n\t        value = JSON.parse(value);\n\t      } catch (err) {\n\t        // .console.warn('Failed decode json: \"' + value + '\" to Array');\n\t        value = null;\n\t      }\n\t      break;\n\t\n\t    case Date:\n\t      value = new Date(value);\n\t      break;\n\t\n\t    // behave like default for now\n\t    // case String:\n\t    default:\n\t      break;\n\t  }\n\t  return value;\n\t}\n\t\n\tmodule.exports.serialize = serialize;\n\tmodule.exports.deserialize = deserialize;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** t.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a006347fa09d87b1683d\n **/","/* globals Node, HTMLUnknownElement */\nconst Expr = require('./expr');\nconst Binding = require('./binding');\nconst Accessor = require('./accessor');\nconst Annotation = require('./annotation');\nconst Token = require('./token');\nconst Serializer = require('./serializer');\n\nconst SLOT_SUPPORTED = 'HTMLUnknownElement' in window && !(document.createElement('slot') instanceof HTMLUnknownElement);\n\nlet templateId = 0;\n\nfunction nextId () {\n  return templateId++;\n}\n\nfunction slotName (element) {\n  return SLOT_SUPPORTED ? element.name : element.getAttribute('name');\n}\n\nfunction slotAppend (slot, node, root) {\n  if (!slot.__appended) {\n    slot.__appended = true;\n    slot.__fallbackContent = slot.innerHTML;\n    slot.innerHTML = '';\n  }\n\n  slot.appendChild(node);\n}\n\nfunction elementSlot (element) {\n  return SLOT_SUPPORTED ? element.slot : element.getAttribute('slot');\n}\n\nfunction fixTemplate (template) {\n  if (!template.content && window.HTMLTemplateElement && window.HTMLTemplateElement.decorate) {\n    window.HTMLTemplateElement.decorate(template);\n  }\n  return template;\n}\n\nfunction T (template, host, marker) {\n  this.__templateInitialize(template, host, marker);\n}\n\nT.prototype = {\n  __templateInitialize (template, host, marker) {\n    this.__templateId = nextId();\n    // this.__templateAnnotatedElements = [];\n    this.__templateBindings = {};\n    this.__templateHost = host || (template ? template.parentElement : null);\n    this.__templateMarker = marker;\n    this.$ = {};\n\n    if (!template) {\n      return;\n    }\n\n    // do below only if template is exists\n    this.__template = fixTemplate(template);\n    this.__templateFragment = document.importNode(this.__template.content, true);\n\n    this.__parseAnnotations();\n\n    if (marker) {\n      return;\n    }\n\n    if (this.__template.parentElement === this.__templateHost) {\n      // when template parent is template host, it means that template is specific template\n      // then use template as marker\n      this.__templateMarker = this.__template;\n    } else {\n      // when template is not child of host, put marker to host\n      this.__templateMarker = document.createComment(`marker-${this.__templateId}`);\n      this.__templateHost.appendChild(this.__templateMarker);\n    }\n  },\n\n  $$ (selector) {\n    return this.querySelector(selector);\n  },\n\n  render (content) {\n    if (!this.__templateFragment) {\n      return;\n    }\n\n    if (content) {\n      try {\n        [].forEach.call(this.__templateFragment.querySelectorAll('slot'), slot => {\n          let name = slotName(slot);\n          if (name) {\n            content.forEach(node => {\n              if (node.nodeType === Node.ELEMENT_NODE && name === elementSlot(node)) {\n                slotAppend(slot, node, this.__templateFragment);\n              }\n              // TODO query to childnodes looking for slot\n            });\n          } else {\n            content.forEach(node => {\n              slotAppend(slot, node, this.__templateFragment);\n            });\n          }\n        });\n      } catch (err) {\n        console.error(err.stack);\n        throw err;\n      }\n    }\n\n    this.__templateMarker.parentElement.insertBefore(this.__templateFragment, this.__templateMarker);\n  },\n\n  get (path) {\n    let object = this;\n\n    let segments = path.split('.');\n\n    segments.some(segment => {\n      if (object === undefined || object === null) {\n        object = undefined;\n        return true;\n      }\n\n      object = object[segment];\n      return false;\n    });\n\n    return object;\n  },\n\n  set (path, value) {\n    let oldValue = this.get(path);\n\n    if (value === oldValue) {\n      return;\n    }\n\n    let object = this;\n\n    let segments = path.split('.');\n\n    segments.slice(0, -1).forEach(segment => {\n      if (!object) {\n        return;\n      }\n      if (object[segment] === undefined || object[segment] === null) {\n        object[segment] = {};\n      }\n\n      object = object[segment];\n    });\n\n    let property = segments.slice(-1).pop();\n\n    object[property] = value;\n\n    this.notify(path, value, oldValue);\n  },\n\n  notify (path, value, oldValue) {\n    try {\n      let binding = this.__templateGetBinding(path);\n      if (binding) {\n        binding.walkEffect(value);\n      }\n    } catch (err) {\n      console.warn(`#notify caught error: ${err.message}\\n Stack trace: ${err.stack}`);\n    }\n  },\n\n  __parseAnnotations () {\n    // this.__templateAnnotatedElements = [];\n\n    // [].forEach.call(this.__templateFragment.querySelectorAll('*'), (el) => {\n    //   console.warn(this.is, !!el.__templateModel, el);\n    // });\n\n    let len = this.__templateFragment.childNodes.length;\n    for (let i = 0; i < len; i++) {\n      let node = this.__templateFragment.childNodes[i];\n      switch (node.nodeType) {\n        case Node.ELEMENT_NODE:\n          this.__parseElementAnnotations(node);\n          break;\n        case Node.TEXT_NODE:\n          this.__parseTextAnnotations(node);\n          break;\n      }\n    }\n\n    Object.keys(this.__templateBindings).forEach(key => {\n      this.notify(key, this.get(key));\n    });\n  },\n\n  __parseEventAnnotations (element, attrName) {\n    // bind event annotation\n    let attrValue = element.getAttribute(attrName);\n    let eventName = attrName.slice(1, -1);\n    // let eventName = attrName.substr(3);\n    if (eventName === 'tap') {\n      eventName = 'click';\n    }\n\n    let context = this;\n    let expr = Expr.getFn(attrValue, [], true);\n\n    // TODO might be slow or memory leak setting event listener to inside element\n    element.addEventListener(eventName, function (evt) {\n      return expr.invoke(context, { evt });\n    }, true);\n  },\n\n  __parseAttributeAnnotations (element) {\n    // clone attributes to array first then foreach because we will remove\n    // attribute later if already processed\n    // this hack to make sure when attribute removed the attributes index doesnt shift.\n    return Array.prototype.slice.call(element.attributes).reduce((annotated, attr) => {\n      let attrName = attr.name;\n\n      if (attrName.indexOf('(') === 0) {\n        this.__parseEventAnnotations(element, attrName);\n      } else {\n        // bind property annotation\n        annotated = this.__templateAnnotate(Expr.get(attr.value), Accessor.get(element, attrName)) || annotated;\n      }\n\n      return annotated;\n    }, false);\n  },\n\n  __parseElementAnnotations (element) {\n    let annotated = false;\n    let scoped = element.__templateModel;\n\n    if (!scoped) {\n      element.classList.add(`${this.__templateHost.is}__scope`);\n      element.__templateModel = this;\n\n      // populate $\n      if (element.id && !this.$[element.id]) {\n        this.$[element.id] = element;\n      }\n\n      if (element.attributes && element.attributes.length) {\n        annotated = this.__parseAttributeAnnotations(element) || annotated;\n      }\n    }\n\n    if (element.childNodes && element.childNodes.length) {\n      let childNodes = [].slice.call(element.childNodes);\n      let childNodesLength = childNodes.length;\n\n      for (let i = 0; i < childNodesLength; i++) {\n        let childNode = childNodes[i];\n\n        switch (childNode.nodeType) {\n          case Node.TEXT_NODE:\n            if (!scoped) {\n              annotated = this.__parseTextAnnotations(childNode) || annotated;\n            }\n            break;\n          case Node.ELEMENT_NODE:\n            annotated = this.__parseElementAnnotations(childNode) || annotated;\n            break;\n          default:\n            // noop\n        }\n      }\n    }\n\n    // if (annotated) {\n    //   this.__templateAnnotatedElements.push(element);\n    // }\n\n    return annotated;\n  },\n\n  __parseTextAnnotations (node) {\n    let expr = Expr.get(node.textContent);\n\n    let accessor;\n    if (node.parentElement && node.parentElement.nodeName === 'TEXTAREA') {\n      accessor = Accessor.get(node.parentElement, 'value');\n    } else {\n      accessor = Accessor.get(node);\n    }\n\n    return this.__templateAnnotate(expr, accessor);\n  },\n\n  __templateAnnotate (expr, accessor) {\n    if (expr.type === 's') {\n      return false;\n    }\n\n    // annotate every paths\n    let annotation = new Annotation(this, expr, accessor);\n\n    expr.annotatedPaths.forEach(arg => this.__templateGetBinding(arg.name).annotations.push(annotation));\n\n    return true;\n  },\n\n  __templateGetBinding (path) {\n    let segments = path.split('.');\n    let bindings;\n    let binding;\n\n    for (let i = 0; i < segments.length; i++) {\n      let segment = segments[i];\n\n      bindings = binding ? binding.paths : this.__templateBindings;\n\n      if (!bindings[segment]) {\n        bindings[segment] = new Binding(this, segment);\n      }\n\n      binding = bindings[segment];\n    }\n\n    return binding;\n  },\n};\n\nif (typeof window === 'object') {\n  window.T = T;\n}\n\nmodule.exports = T;\nmodule.exports.Accessor = Accessor;\nmodule.exports.Expr = Expr;\nmodule.exports.Token = Token;\nmodule.exports.Serializer = Serializer;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","const Token = require('./token');\n\nclass Expr {\n  constructor (value, unwrapped) {\n    // define base properties\n    this.mode = '[';\n    this.type = 's';\n    this.name = '';\n    this.args = [];\n    this.value = value;\n    this.unwrapped = Boolean(unwrapped);\n\n    let valType = typeof value;\n    if (valType === 'function') {\n      this.type = 'm';\n      return;\n    } else if (valType !== 'string') {\n      // validate args\n      return;\n    }\n\n    // cleanse value\n    value = value.trim();\n\n    let token = value;\n    if (!this.unwrapped) {\n      if (value[0] !== '[' && value[0] !== '{') {\n        return;\n      }\n      token = value.slice(2, -2).trim();\n      this.mode = value[0];\n    }\n\n    if (token.indexOf('(') < 0) {\n      this.type = 'p';\n      this.name = token;\n      this.args.push(new Token(token));\n    } else {\n      // force mode to '[' when type is !p\n      this.mode = '[';\n      this.type = 'm';\n\n      let matches = token.match(/([^(]+)\\(([^)]*)\\)/);\n\n      this.name = matches[1].trim();\n\n      this.args = tokenize(matches[2]);\n    }\n  }\n\n  get annotatedPaths () {\n    if (!this._annotatedPaths) {\n      let annotatedPaths = [];\n      this.args.forEach(arg => {\n        if (arg.type === 'v' && annotatedPaths.indexOf(arg.name) === -1) {\n          annotatedPaths.push(arg);\n        }\n      });\n      this._annotatedPaths = annotatedPaths;\n    }\n\n    return this._annotatedPaths;\n  }\n\n  invoke (context, otherArgs) {\n    if (this.type === 'p') {\n      return typeof context.get === 'function' ? context.get(this.name) : context[this.name];\n    }\n\n    let fn = context.__templateHost[this.name];\n    if (typeof fn !== 'function') {\n      throw new Error(`Method is not eligible, ${context.__templateHost.nodeName || '$anonymous'}#${this.name}`);\n    }\n\n\n    let args = this.args.map(arg => {\n      return arg.value(context, otherArgs);\n    });\n\n\n    return fn.apply(context, args);\n  }\n}\n\nfunction get (value, unwrapped) {\n  // FIXME implement cache\n  return new Expr(value, unwrapped);\n}\n\nfunction getFn (value, args, unwrapped) {\n  if (typeof value === 'function') {\n    return get(value, unwrapped);\n  }\n  return get(value.indexOf('(') === -1 ? (value + '(' + args.join(', ') + ')') : value, unwrapped);\n}\n\nfunction rawTokenize (str) {\n  let count = 0;\n  let tokens = [];\n\n  while (str && count++ < 10) {\n    let matches = str.match(/^\\s*(\"[^\"]*\"|[^,]+),?/);\n\n    str = str.substr(matches[0].length);\n    tokens.push(matches[1].trim());\n  }\n\n  return tokens;\n}\n\nfunction tokenize (str) {\n  return rawTokenize(str).map(token => new Token(token));\n}\n\nmodule.exports = Expr;\nmodule.exports.getFn = getFn;\nmodule.exports.get = get;\nmodule.exports.rawTokenize = rawTokenize;\nmodule.exports.tokenize = tokenize;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/expr.js\n **/","const GLOBAL = global || window;\n\nclass Token {\n  constructor (name) {\n    this.name = name;\n    try {\n      let value = JSON.parse(this.name);\n      this.type = 's';\n      this._value = value;\n    } catch (err) {\n      this.type = 'v';\n      this._value = null;\n    }\n  }\n\n  value (context, others) {\n    context = context || GLOBAL;\n\n    if (this.type === 's') {\n      return this._value;\n    }\n\n    if (context) {\n      let val = context.get ? context.get(this.name) : context[this.name];\n      if (typeof val !== 'undefined') {\n        return val;\n      }\n    }\n\n    if (others) {\n      let val = others.get ? others.get(this.name) : others[this.name];\n      if (typeof val !== 'undefined') {\n        return val;\n      }\n    }\n\n    return;\n  }\n}\n\nfunction get (name) {\n  // FIXME implement cache\n  return new Token(name);\n}\n\nmodule.exports = Token;\nmodule.exports.get = get;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/token.js\n **/","class Binding {\n  constructor (context, model) {\n    this.context = context;\n    this.model = model;\n    this.paths = {};\n    this.annotations = [];\n  }\n\n  walkEffect (value) {\n    this.annotations.forEach(annotation => {\n      try {\n        annotation.effect(value, this.model);\n      } catch (err) {\n        console.error(`Error caught while walk effect annotation: ${annotation.expr ? annotation.expr.value : '#unknown'}\\n ${err.stack}`);\n      }\n    });\n\n    Object.keys(this.paths).forEach(i => {\n      this.paths[i].walkEffect(value ? value[i] : undefined);\n    });\n  }\n}\n\nmodule.exports = Binding;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/binding.js\n **/","/* globals Node */\n\nclass BaseAccessor {\n  constructor (node, name) {\n    this.node = node;\n    this.name = name;\n  }\n\n  set (value) {\n    if (typeof this.node.set === 'function') {\n      this.node.set(this.name, value);\n    } else {\n      this.node[this.name] = value;\n    }\n  }\n\n  get () {\n    if (typeof this.node.get === 'function') {\n      return this.node.get(this.name);\n    } else {\n      return this.node[this.name];\n    }\n  }\n}\n\nclass TextAccessor extends BaseAccessor {\n  constructor (node) {\n    super(node, 'textContent');\n  }\n\n  set (value) {\n    this.node.textContent = value || '';\n  }\n\n  get () {\n    return this.node.textContext;\n  }\n}\n\nclass ValueAccessor extends BaseAccessor {\n  set (value) {\n    super.set(value || '');\n  }\n}\n\nclass AttributeAccessor extends BaseAccessor {\n  constructor (node, name) {\n    super(node, name.slice(0, -1));\n  }\n\n  set (value) {\n    if (value) {\n      this.node.setAttribute(this.name, value);\n    } else {\n      this.node.removeAttribute(this.name);\n    }\n  }\n\n  get () {\n    return this.node.getAttribute(this.name);\n  }\n}\n\nfunction get (node, name) {\n  if (node && 'nodeType' in node) {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        if (name.endsWith('$')) {\n          return new AttributeAccessor(node, name);\n        } else if (name === 'value') {\n          return new ValueAccessor(node, name);\n        }\n\n        return new BaseAccessor(node, name);\n      case Node.TEXT_NODE:\n        if (node.parentElement && node.parentElement.nodeName === 'TEXTAREA') {\n          return new ValueAccessor(node.parentElement, 'value');\n        }\n\n        return new TextAccessor(node);\n      default:\n        throw new Error(`Unimplemented resolving accessor for nodeType: ${node.nodeType}`);\n    }\n  } else {\n    return new BaseAccessor(node, name);\n  }\n}\n\nmodule.exports = BaseAccessor;\nmodule.exports.get = get;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/accessor.js\n **/","class Annotation {\n  constructor (model, expr, accessor) {\n    this.model = model;\n    this.expr = expr;\n    this.accessor = accessor;\n  }\n\n  effect (value) {\n    if (this.accessor) {\n      let value = this.expr.invoke(this.model);\n      // FIXME implement composite annotation\n      // FIXME implement filtered annotation\n      // FIXME implement function type annotation\n      this.accessor.set(value);\n    } else {\n      this.expr.invoke(this.model);\n    }\n  }\n}\n\nmodule.exports = Annotation;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/annotation.js\n **/","function serialize (value) {\n  switch (typeof value) {\n    case 'boolean':\n      return value ? '' : undefined;\n\n    case 'object':\n      if (value instanceof Date) {\n        return value;\n      } else if (value) {\n        try {\n          return JSON.stringify(value);\n        } catch (err) {\n          return '';\n        }\n      }\n      break;\n    default:\n      // noop\n  }\n  return value === null ? undefined : value;\n}\n\nfunction deserialize (value, type) {\n  switch (type) {\n    case Number:\n      value = Number(value);\n      break;\n\n    case Boolean:\n      value = Boolean(value === '' || value === 'true' || value === '1' || value === 'on');\n      break;\n\n    case Object:\n      try {\n        value = JSON.parse(value);\n      } catch (err) {\n        // allow non-JSON literals like Strings and Numbers\n        // console.warn('Failed decode json: \"' + value + '\" to Object');\n      }\n      break;\n\n    case Array:\n      try {\n        value = JSON.parse(value);\n      } catch (err) {\n        // .console.warn('Failed decode json: \"' + value + '\" to Array');\n        value = null;\n      }\n      break;\n\n    case Date:\n      value = new Date(value);\n      break;\n\n    // behave like default for now\n    // case String:\n    default:\n      break;\n  }\n  return value;\n}\n\nmodule.exports.serialize = serialize;\nmodule.exports.deserialize = deserialize;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/serializer.js\n **/"],"sourceRoot":""}